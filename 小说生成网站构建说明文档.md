# 小说生成网站构建说明文档

## 项目概述

本项目旨在构建一个智能小说生成网站，用户可以通过投喂《构建小说所需材料.md》中的小说类别材料，系统自动生成对应的小说内容。生成的小说将包含大量主角对白，确保使用指定的汉字材料，并提供沉浸式的主角扮演体验。

**核心特色**: 用户扮演小说主角，无需输入对白，通过阅读主角台词和确认推进来体验小说剧情发展。

## 核心功能需求

### 1. 材料投喂系统
- 支持上传构建小说所需材料的文件（一定要支持md格式的）
- 自动解析小说类别、写作指导、构建小说必须用到的字
- 验证材料完整性和格式正确性

### 2. 小说生成引擎
- 基于投喂材料自动生成小说大纲
- 生成包含大量对白的小说内容
- 确保主角对白中使用指定的汉字材料
- 支持多种小说风格和类型
- 智能识别主角对白和其他角色对白

### 3. 沉浸式主角扮演系统
- 用户扮演小说主角，无需输入任何对白内容
- 系统自动展示主角的台词，用户阅读后点击"确认读完"
- 确认后剧情自动推进，展示其他角色的对白和情节发展
- 直到下一句主角台词出现时再次暂停，等待用户确认
- 实时显示剧情进度和对白历史记录

### 4. 小说展示页面
- 完整小说内容展示
- 主角扮演界面
- 角色信息展示
- 小说进度跟踪
- 剧情推进控制
- 对白历史记录查看

## 技术架构设计

### 前端技术栈
```
- React 18.x (主框架)
- TypeScript (类型安全)
- Tailwind CSS (样式框架)
- React Router (路由管理)
- Zustand (状态管理)
- Axios (HTTP客户端)
```

### 后端技术栈
```
- Python 3.9+ (主语言)
- FastAPI (Web框架)
- SQLAlchemy (ORM)
- PostgreSQL (数据库)
- Redis (缓存)
- Celery (异步任务)
- OpenAI API / 本地LLM (小说生成)
```

### 系统架构图
```
用户界面层 (React)
    ↓
API网关层 (FastAPI)
    ↓
业务逻辑层 (Python)
    ↓
数据存储层 (PostgreSQL + Redis)
    ↓
AI生成层 (LLM API)
```

## 数据库设计

### 核心数据表

#### 1. 小说类别表 (novel_categories)
```sql
CREATE TABLE novel_categories (
    id SERIAL PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL,
    description TEXT,
    writing_guide JSONB,
    required_chars JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 2. 小说表 (novels)
```sql
CREATE TABLE novels (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    category_id INTEGER REFERENCES novel_categories(id),
    outline TEXT,
    content TEXT,
    status VARCHAR(20) DEFAULT 'draft',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3. 对白表 (dialogues)
```sql
CREATE TABLE dialogues (
    id SERIAL PRIMARY KEY,
    novel_id INTEGER REFERENCES novels(id),
    chapter_id INTEGER,
    speaker_role VARCHAR(50),
    dialogue_text TEXT,
    required_chars_used JSONB,
    sequence_order INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 4. 用户会话表 (user_sessions)
```sql
CREATE TABLE user_sessions (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(100) UNIQUE,
    novel_id INTEGER REFERENCES novels(id),
    current_chapter INTEGER DEFAULT 1,
    dialogue_history JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 核心功能实现方案

### 1. 材料解析模块

#### 功能描述
解析上传的Markdown文件，提取小说类别信息、写作指导和必需汉字。

#### 实现代码示例
```python
import re
import json
from typing import Dict, List, Any

class MaterialParser:
    def __init__(self, markdown_content: str):
        self.content = markdown_content
        self.categories = []
    
    def parse_categories(self) -> List[Dict[str, Any]]:
        """解析小说类别"""
        category_pattern = r'### 第(\d+)类: (.+?)\n\n\*\*示例小说\*\*: (.+?)\n\n\*\*写作指导\*\*:(.+?)\*\*拼音汉字对数\*\*: (\d+)个\n\n\*\*构建小说必须用到的字\*\*:(.+?)(?=---|\Z)'
        
        matches = re.findall(category_pattern, self.content, re.DOTALL)
        
        for match in matches:
            category = {
                'id': int(match[0]),
                'name': match[1].strip(),
                'examples': match[2].strip(),
                'writing_guide': self._parse_writing_guide(match[3]),
                'char_count': int(match[4]),
                'required_chars': self._parse_required_chars(match[5])
            }
            self.categories.append(category)
        
        return self.categories
    
    def _parse_writing_guide(self, guide_text: str) -> Dict[str, str]:
        """解析写作指导"""
        guide = {}
        lines = guide_text.strip().split('\n')
        current_key = None
        
        for line in lines:
            if line.strip().startswith('- **'):
                key_match = re.search(r'- \*\*(.+?)\*\*: (.+)', line)
                if key_match:
                    current_key = key_match.group(1)
                    guide[current_key] = key_match.group(2).strip()
        
        return guide
    
    def _parse_required_chars(self, chars_text: str) -> List[Dict[str, str]]:
        """解析必需汉字"""
        chars = []
        lines = chars_text.strip().split('\n')
        
        for line in lines:
            if '→' in line:
                parts = line.split('→')
                if len(parts) == 2:
                    chars.append({
                        'pinyin': parts[0].strip().split('. ')[1] if '. ' in parts[0] else parts[0].strip(),
                        'character': parts[1].strip()
                    })
        
        return chars
```

### 2. 小说生成引擎

#### 功能描述
基于解析的材料，使用AI模型生成完整的小说内容，确保包含大量对白并使用指定汉字。

#### 实现代码示例
```python
from typing import List, Dict, Any
import openai
import json

class NovelGenerator:
    def __init__(self, api_key: str):
        self.client = openai.OpenAI(api_key=api_key)
    
    def generate_novel(self, category: Dict[str, Any]) -> Dict[str, Any]:
        """生成小说"""
        # 构建提示词
        prompt = self._build_prompt(category)
        
        # 调用AI生成
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "你是一个专业的小说创作助手，擅长创作包含大量对白的小说。"},
                {"role": "user", "content": prompt}
            ],
            max_tokens=4000,
            temperature=0.8
        )
        
        # 解析生成内容
        novel_content = response.choices[0].message.content
        return self._parse_novel_content(novel_content, category)
    
    def _build_prompt(self, category: Dict[str, Any]) -> str:
        """构建AI提示词"""
        required_chars = [char['character'] for char in category['required_chars']]
        
        prompt = f"""
        请根据以下要求创作一部小说：
        
        类别：{category['name']}
        示例：{category['examples']}
        写作指导：{json.dumps(category['writing_guide'], ensure_ascii=False)}
        
        要求：
        1. 小说必须包含大量角色对白
        2. 所有对白必须使用以下汉字：{', '.join(required_chars)}
        3. 对白要自然流畅，符合角色性格
        4. 小说结构完整，包含开头、发展、高潮、结尾
        5. 每个章节至少包含10段对白
        
        请以JSON格式返回，包含以下结构：
        {{
            "title": "小说标题",
            "outline": "小说大纲",
            "chapters": [
                {{
                    "chapter_id": 1,
                    "title": "章节标题",
                    "content": "章节内容",
                    "dialogues": [
                        {{
                            "speaker": "角色名",
                            "text": "对白内容",
                            "required_chars_used": ["使用的汉字"]
                        }}
                    ]
                }}
            ]
        }}
        """
        return prompt
    
    def _parse_novel_content(self, content: str, category: Dict[str, Any]) -> Dict[str, Any]:
        """解析AI生成的小说内容"""
        try:
            novel_data = json.loads(content)
            return {
                'title': novel_data.get('title', ''),
                'outline': novel_data.get('outline', ''),
                'chapters': novel_data.get('chapters', []),
                'category_id': category['id']
            }
        except json.JSONDecodeError:
            # 如果解析失败，返回默认结构
            return {
                'title': f"{category['name']}小说",
                'outline': 'AI生成的小说大纲',
                'chapters': [],
                'category_id': category['id']
            }
```

### 3. 沉浸式主角扮演系统

#### 功能描述
实现用户扮演小说主角的沉浸式体验，用户无需输入对白，通过阅读和确认来推进剧情发展。

#### 实现代码示例
```python
from typing import List, Dict, Any
import uuid

class ProtagonistRoleplaySystem:
    def __init__(self):
        self.active_sessions = {}
    
    def create_session(self, novel_id: int) -> str:
        """创建用户主角扮演会话"""
        session_id = str(uuid.uuid4())
        self.active_sessions[session_id] = {
            'novel_id': novel_id,
            'current_chapter': 1,
            'dialogue_history': [],
            'current_dialogue_index': 0,
            'waiting_for_user_confirmation': False,
            'current_protagonist_dialogue': None
        }
        return session_id
    
    def get_current_dialogue(self, session_id: str) -> Dict[str, Any]:
        """获取当前对白状态"""
        if session_id not in self.active_sessions:
            raise ValueError("Invalid session ID")
        
        session = self.active_sessions[session_id]
        
        # 获取当前章节的对白
        current_dialogues = self._get_chapter_dialogues(
            session['novel_id'], 
            session['current_chapter']
        )
        
        if session['current_dialogue_index'] >= len(current_dialogues):
            return {
                'speaker': '系统',
                'text': '本章节已结束，是否进入下一章节？',
                'required_chars_used': [],
                'is_end_of_chapter': True,
                'is_protagonist_dialogue': False
            }
        
        current_dialogue = current_dialogues[session['current_dialogue_index']]
        
        # 判断是否是主角对白
        is_protagonist = current_dialogue['speaker'] == '主角'
        
        if is_protagonist and not session['waiting_for_user_confirmation']:
            # 主角对白，等待用户确认
            session['waiting_for_user_confirmation'] = True
            session['current_protagonist_dialogue'] = current_dialogue
            return {
                'speaker': '主角',
                'text': current_dialogue['text'],
                'required_chars_used': current_dialogue.get('required_chars_used', []),
                'is_protagonist_dialogue': True,
                'waiting_confirmation': True,
                'message': '请阅读完主角台词后点击"确认读完"继续剧情'
            }
        elif not is_protagonist:
            # 其他角色对白，自动推进
            session['current_dialogue_index'] += 1
            session['waiting_for_user_confirmation'] = False
            
            # 记录对白历史
            session['dialogue_history'].append({
                'speaker': current_dialogue['speaker'],
                'text': current_dialogue['text'],
                'timestamp': datetime.now().isoformat(),
                'is_protagonist': False
            })
            
            return {
                'speaker': current_dialogue['speaker'],
                'text': current_dialogue['text'],
                'required_chars_used': current_dialogue.get('required_chars_used', []),
                'is_protagonist_dialogue': False,
                'auto_advance': True
            }
        
        return {
            'speaker': '系统',
            'text': '等待用户确认主角台词',
            'required_chars_used': [],
            'is_protagonist_dialogue': False,
            'waiting_confirmation': True
        }
    
    def confirm_protagonist_dialogue(self, session_id: str) -> Dict[str, Any]:
        """用户确认已读完主角台词"""
        if session_id not in self.active_sessions:
            raise ValueError("Invalid session ID")
        
        session = self.active_sessions[session_id]
        
        if not session['waiting_for_user_confirmation']:
            return {
                'error': '当前无需确认主角台词'
            }
        
        # 记录主角对白历史
        if session['current_protagonist_dialogue']:
            session['dialogue_history'].append({
                'speaker': '主角',
                'text': session['current_protagonist_dialogue']['text'],
                'timestamp': datetime.now().isoformat(),
                'is_protagonist': True
            })
        
        # 推进到下一个对白
        session['current_dialogue_index'] += 1
        session['waiting_for_user_confirmation'] = False
        session['current_protagonist_dialogue'] = None
        
        # 获取下一个对白
        return self.get_current_dialogue(session_id)
    
    def _get_chapter_dialogues(self, novel_id: int, chapter_id: int) -> List[Dict[str, Any]]:
        """获取指定章节的对白列表"""
        # 这里应该从数据库查询
        # 暂时返回模拟数据
        return [
            {
                'speaker': '主角',
                'text': '我来到这个陌生的世界，心中充满了好奇和期待。',
                'required_chars_used': ['我', '来', '到', '这', '个', '陌', '生', '的', '世', '界']
            },
            {
                'speaker': '向导',
                'text': '欢迎来到这个奇妙的世界！',
                'required_chars_used': ['世', '界']
            },
            {
                'speaker': '主角',
                'text': '这里的一切都让我感到新奇，我想了解更多。',
                'required_chars_used': ['这', '里', '的', '一', '切', '都', '让', '我', '感', '到', '新', '奇']
            }
        ]
```

## 前端界面设计

### 1. 主页面布局
```
┌─────────────────────────────────────┐
│ 小说生成网站 - 智能创作平台        │
├─────────────────────────────────────┤
│ [上传材料] [选择类别] [开始创作]    │
├─────────────────────────────────────┤
│ 小说列表 | 创作中心 | 对白体验      │
└─────────────────────────────────────┘
```

### 2. 材料上传界面
```jsx
import React, { useState } from 'react';
import { Upload, Button, message } from 'antd';
import { InboxOutlined } from '@ant-design/icons';

const MaterialUpload: React.FC = () => {
  const [fileList, setFileList] = useState([]);
  const [uploading, setUploading] = useState(false);

  const handleUpload = async () => {
    const formData = new FormData();
    fileList.forEach(file => {
      formData.append('files[]', file);
    });

    setUploading(true);

    try {
      const response = await fetch('/api/upload-materials', {
        method: 'POST',
        body: formData,
      });
      
      if (response.ok) {
        message.success('材料上传成功！');
        // 跳转到类别选择页面
      }
    } catch (error) {
      message.error('上传失败，请重试');
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="upload-container">
      <Upload.Dragger
        fileList={fileList}
        onChange={({ fileList }) => setFileList(fileList)}
        beforeUpload={() => false}
        accept=".md,.txt"
      >
        <p className="ant-upload-drag-icon">
          <InboxOutlined />
        </p>
        <p className="ant-upload-text">点击或拖拽文件到此区域上传</p>
        <p className="ant-upload-hint">
          支持 Markdown 和文本文件格式
        </p>
      </Upload.Dragger>
      
      <Button
        type="primary"
        onClick={handleUpload}
        loading={uploading}
        disabled={fileList.length === 0}
        style={{ marginTop: 16 }}
      >
        {uploading ? '上传中' : '开始上传'}
      </Button>
    </div>
  );
};

export default MaterialUpload;
```

### 3. 主角扮演界面
```jsx
import React, { useState, useEffect, useRef } from 'react';
import { Input, Button, Card, Avatar, Space } from 'antd';
import { SendOutlined, UserOutlined, RobotOutlined } from '@ant-design/icons';

const ProtagonistRoleplayInterface: React.FC<{ novelId: number }> = ({ novelId }) => {
  const [currentDialogue, setCurrentDialogue] = useState(null);
  const [dialogueHistory, setDialogueHistory] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [waitingConfirmation, setWaitingConfirmation] = useState(false);
  const dialogueEndRef = useRef(null);

  const scrollToBottom = () => {
    dialogueEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [dialogueHistory]);

  // 初始化获取第一个对白
  useEffect(() => {
    getCurrentDialogue();
  }, []);

  const getCurrentDialogue = async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/dialogue/current', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          novelId,
          sessionId: localStorage.getItem('sessionId')
        })
      });

      const data = await response.json();
      setCurrentDialogue(data);
      setWaitingConfirmation(data.waiting_confirmation || false);
      
      if (data.auto_advance) {
        // 自动推进的对白，添加到历史记录
        setDialogueHistory(prev => [...prev, {
          id: Date.now(),
          speaker: data.speaker,
          text: data.text,
          timestamp: new Date().toISOString(),
          isProtagonist: false,
          requiredChars: data.required_chars_used
        }]);
        
        // 继续获取下一个对白
        setTimeout(() => getCurrentDialogue(), 1000);
      }
    } catch (error) {
      console.error('获取对白失败:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleConfirmRead = async () => {
    if (!waitingConfirmation) return;
    
    setIsLoading(true);
    try {
      const response = await fetch('/api/dialogue/confirm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          novelId,
          sessionId: localStorage.getItem('sessionId')
        })
      });

      const data = await response.json();
      
      if (data.error) {
        console.error(data.error);
        return;
      }
      
      // 将主角对白添加到历史记录
      if (currentDialogue && currentDialogue.is_protagonist_dialogue) {
        setDialogueHistory(prev => [...prev, {
          id: Date.now(),
          speaker: '主角',
          text: currentDialogue.text,
          timestamp: new Date().toISOString(),
          isProtagonist: true,
          requiredChars: currentDialogue.required_chars_used
        }]);
      }
      
      // 获取下一个对白
      setCurrentDialogue(data);
      setWaitingConfirmation(data.waiting_confirmation || false);
      
      if (data.auto_advance) {
        // 自动推进的对白，添加到历史记录
        setDialogueHistory(prev => [...prev, {
          id: Date.now(),
          speaker: data.speaker,
          text: data.text,
          timestamp: new Date().toISOString(),
          isProtagonist: false,
          requiredChars: data.required_chars_used
        }]);
        
        // 继续获取下一个对白
        setTimeout(() => getCurrentDialogue(), 1000);
      }
    } catch (error) {
      console.error('确认失败:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="protagonist-roleplay-container">
      <div className="roleplay-header">
        <h2>主角扮演体验 - 沉浸式小说体验</h2>
        <p>你扮演小说主角，阅读主角台词后点击确认继续剧情</p>
      </div>

      {/* 当前对白显示区域 */}
      {currentDialogue && (
        <div className="current-dialogue">
          <Card
            className={`dialogue-card ${currentDialogue.is_protagonist_dialogue ? 'protagonist-dialogue' : 'other-dialogue'}`}
            size="large"
          >
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <div className="speaker-info">
                <Avatar
                  icon={currentDialogue.is_protagonist_dialogue ? <UserOutlined /> : <RobotOutlined />}
                  className={currentDialogue.is_protagonist_dialogue ? 'protagonist-avatar' : 'other-avatar'}
                  size={64}
                />
                <div className="speaker-name">
                  {currentDialogue.is_protagonist_dialogue ? '你 (主角)' : currentDialogue.speaker}
                </div>
              </div>
              
              <div className="dialogue-text">
                {currentDialogue.text}
              </div>
              
              {currentDialogue.required_chars_used && (
                <div className="required-chars">
                  <strong>使用汉字:</strong> {currentDialogue.required_chars_used.join(', ')}
                </div>
              )}
              
              {currentDialogue.waiting_confirmation && (
                <div className="confirmation-message">
                  {currentDialogue.message || '请阅读完主角台词后点击下方按钮继续剧情'}
                </div>
              )}
            </Space>
          </Card>
        </div>
      )}

      {/* 确认按钮 */}
      {waitingConfirmation && (
        <div className="confirmation-area">
          <Button
            type="primary"
            size="large"
            onClick={handleConfirmRead}
            loading={isLoading}
            style={{ fontSize: '18px', padding: '12px 32px' }}
          >
            确认读完，继续剧情
          </Button>
        </div>
      )}

      {/* 对白历史记录 */}
      <div className="dialogue-history">
        <h3>剧情发展记录</h3>
        {dialogueHistory.map(dialogue => (
          <Card
            key={dialogue.id}
            className={`history-dialogue ${dialogue.isProtagonist ? 'protagonist-history' : 'other-history'}`}
            size="small"
          >
            <Space>
              <Avatar
                icon={dialogue.isProtagonist ? <UserOutlined /> : <RobotOutlined />}
                className={dialogue.isProtagonist ? 'protagonist-avatar' : 'other-avatar'}
              />
              <div className="dialogue-content">
                <div className="speaker-name">
                  {dialogue.isProtagonist ? '你 (主角)' : dialogue.speaker}
                </div>
                <div className="dialogue-text">{dialogue.text}</div>
                {dialogue.requiredChars && (
                  <div className="required-chars">
                    使用汉字: {dialogue.requiredChars.join(', ')}
                  </div>
                )}
                <div className="timestamp">
                  {new Date(dialogue.timestamp).toLocaleTimeString()}
                </div>
              </div>
            </Space>
          </Card>
        ))}
        <div ref={dialogueEndRef} />
      </div>
    </div>
  );
};

export default ProtagonistRoleplayInterface;
```

## API接口设计

### 1. 材料上传接口
```python
@app.post("/api/upload-materials")
async def upload_materials(file: UploadFile = File(...)):
    """上传小说材料文件"""
    try:
        # 读取文件内容
        content = await file.read()
        content_str = content.decode('utf-8')
        
        # 解析材料
        parser = MaterialParser(content_str)
        categories = parser.parse_categories()
        
        # 保存到数据库
        for category in categories:
            await save_category_to_db(category)
        
        return {"success": True, "categories_count": len(categories)}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### 2. 小说生成接口
```python
@app.post("/api/generate-novel")
async def generate_novel(request: NovelGenerationRequest):
    """生成小说"""
    try:
        # 获取类别信息
        category = await get_category_by_id(request.category_id)
        
        # 生成小说
        generator = NovelGenerator(settings.OPENAI_API_KEY)
        novel = generator.generate_novel(category)
        
        # 保存小说
        novel_id = await save_novel_to_db(novel)
        
        return {"success": True, "novel_id": novel_id}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### 3. 主角扮演接口
```python
@app.get("/api/dialogue/current")
async def get_current_dialogue(request: DialogueRequest):
    """获取当前对白状态"""
    try:
        roleplay_system = ProtagonistRoleplaySystem()
        current_dialogue = roleplay_system.get_current_dialogue(request.session_id)
        
        return current_dialogue
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/api/dialogue/confirm")
async def confirm_protagonist_dialogue(request: DialogueRequest):
    """用户确认已读完主角台词"""
    try:
        roleplay_system = ProtagonistRoleplaySystem()
        next_dialogue = roleplay_system.confirm_protagonist_dialogue(request.session_id)
        
        return next_dialogue
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

## 部署方案

### 1. 开发环境
```bash
# 前端开发
cd frontend
npm install
npm run dev

# 后端开发
cd backend
pip install -r requirements.txt
uvicorn main:app --reload
```

### 2. 生产环境
```yaml
# docker-compose.yml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
  
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/novel_db
    depends_on:
      - db
      - redis
  
  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=novel_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
```

## 项目时间规划

### 第一阶段 (2周)
- 项目架构设计
- 数据库设计
- 基础框架搭建

### 第二阶段 (3周)
- 材料解析模块开发
- 小说生成引擎开发
- 基础API接口开发

### 第三阶段 (2周)
- 前端界面开发
- 对白交互系统开发
- 用户界面优化

### 第四阶段 (1周)
- 系统测试
- 性能优化
- 部署上线

## 技术难点与解决方案

### 1. 汉字使用验证
**难点**: 确保生成的对白使用了指定的汉字
**解决方案**: 
- 在AI生成时明确要求使用指定汉字
- 生成后使用正则表达式验证汉字使用情况
- 如果使用不足，自动补充或重新生成

### 2. 对白自然性
**难点**: 确保AI生成的对白自然流畅
**解决方案**:
- 使用高质量的训练数据
- 设置合适的温度参数
- 人工审核和优化提示词

### 3. 剧情推进控制
**难点**: 确保主角对白和剧情推进的节奏控制
**解决方案**:
- 实现智能的剧情暂停和推进机制
- 使用状态机管理用户确认流程
- 异步处理剧情自动推进部分

## 扩展功能建议

### 1. 多语言支持
- 支持英文、日文等其他语言的小说生成
- 多语言对白交互

### 2. 语音合成
- 对白内容转换为语音
- 支持不同角色的声音特征

### 3. 社区功能
- 用户分享创作的小说
- 对白互动评分系统
- 创作排行榜

### 4. 移动端适配
- 响应式设计
- 移动端专用交互方式
- PWA支持

## 总结

本小说生成网站项目将实现一个完整的智能创作平台，通过材料投喂、AI生成、沉浸式主角扮演等核心功能，为用户提供独特的小说体验方式。

**核心创新点**: 
- 用户无需输入任何内容，完全沉浸在主角角色中
- 通过阅读主角台词和确认推进来体验小说剧情
- 智能的剧情暂停和推进机制，确保用户体验的流畅性

项目采用现代化的技术架构，具有良好的扩展性和维护性，能够满足用户对沉浸式小说体验的需求。
